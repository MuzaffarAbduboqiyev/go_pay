// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'monitoring_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MonitoringState {
  NetworkStatus get screenStatus => throw _privateConstructorUsedError;
  NetworkStatus get paginationStatus => throw _privateConstructorUsedError;
  bool get isLastPage => throw _privateConstructorUsedError;
  int get page => throw _privateConstructorUsedError;
  String get from => throw _privateConstructorUsedError;
  String get filterFrom => throw _privateConstructorUsedError;
  String get to => throw _privateConstructorUsedError;
  String get filterTo => throw _privateConstructorUsedError;
  List<MonitoringModel> get monitoringList =>
      throw _privateConstructorUsedError;
  String get error => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MonitoringStateCopyWith<MonitoringState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MonitoringStateCopyWith<$Res> {
  factory $MonitoringStateCopyWith(
          MonitoringState value, $Res Function(MonitoringState) then) =
      _$MonitoringStateCopyWithImpl<$Res, MonitoringState>;
  @useResult
  $Res call(
      {NetworkStatus screenStatus,
      NetworkStatus paginationStatus,
      bool isLastPage,
      int page,
      String from,
      String filterFrom,
      String to,
      String filterTo,
      List<MonitoringModel> monitoringList,
      String error});
}

/// @nodoc
class _$MonitoringStateCopyWithImpl<$Res, $Val extends MonitoringState>
    implements $MonitoringStateCopyWith<$Res> {
  _$MonitoringStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? screenStatus = null,
    Object? paginationStatus = null,
    Object? isLastPage = null,
    Object? page = null,
    Object? from = null,
    Object? filterFrom = null,
    Object? to = null,
    Object? filterTo = null,
    Object? monitoringList = null,
    Object? error = null,
  }) {
    return _then(_value.copyWith(
      screenStatus: null == screenStatus
          ? _value.screenStatus
          : screenStatus // ignore: cast_nullable_to_non_nullable
              as NetworkStatus,
      paginationStatus: null == paginationStatus
          ? _value.paginationStatus
          : paginationStatus // ignore: cast_nullable_to_non_nullable
              as NetworkStatus,
      isLastPage: null == isLastPage
          ? _value.isLastPage
          : isLastPage // ignore: cast_nullable_to_non_nullable
              as bool,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      from: null == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as String,
      filterFrom: null == filterFrom
          ? _value.filterFrom
          : filterFrom // ignore: cast_nullable_to_non_nullable
              as String,
      to: null == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as String,
      filterTo: null == filterTo
          ? _value.filterTo
          : filterTo // ignore: cast_nullable_to_non_nullable
              as String,
      monitoringList: null == monitoringList
          ? _value.monitoringList
          : monitoringList // ignore: cast_nullable_to_non_nullable
              as List<MonitoringModel>,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MonitoringStateImplCopyWith<$Res>
    implements $MonitoringStateCopyWith<$Res> {
  factory _$$MonitoringStateImplCopyWith(_$MonitoringStateImpl value,
          $Res Function(_$MonitoringStateImpl) then) =
      __$$MonitoringStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {NetworkStatus screenStatus,
      NetworkStatus paginationStatus,
      bool isLastPage,
      int page,
      String from,
      String filterFrom,
      String to,
      String filterTo,
      List<MonitoringModel> monitoringList,
      String error});
}

/// @nodoc
class __$$MonitoringStateImplCopyWithImpl<$Res>
    extends _$MonitoringStateCopyWithImpl<$Res, _$MonitoringStateImpl>
    implements _$$MonitoringStateImplCopyWith<$Res> {
  __$$MonitoringStateImplCopyWithImpl(
      _$MonitoringStateImpl _value, $Res Function(_$MonitoringStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? screenStatus = null,
    Object? paginationStatus = null,
    Object? isLastPage = null,
    Object? page = null,
    Object? from = null,
    Object? filterFrom = null,
    Object? to = null,
    Object? filterTo = null,
    Object? monitoringList = null,
    Object? error = null,
  }) {
    return _then(_$MonitoringStateImpl(
      screenStatus: null == screenStatus
          ? _value.screenStatus
          : screenStatus // ignore: cast_nullable_to_non_nullable
              as NetworkStatus,
      paginationStatus: null == paginationStatus
          ? _value.paginationStatus
          : paginationStatus // ignore: cast_nullable_to_non_nullable
              as NetworkStatus,
      isLastPage: null == isLastPage
          ? _value.isLastPage
          : isLastPage // ignore: cast_nullable_to_non_nullable
              as bool,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      from: null == from
          ? _value.from
          : from // ignore: cast_nullable_to_non_nullable
              as String,
      filterFrom: null == filterFrom
          ? _value.filterFrom
          : filterFrom // ignore: cast_nullable_to_non_nullable
              as String,
      to: null == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as String,
      filterTo: null == filterTo
          ? _value.filterTo
          : filterTo // ignore: cast_nullable_to_non_nullable
              as String,
      monitoringList: null == monitoringList
          ? _value._monitoringList
          : monitoringList // ignore: cast_nullable_to_non_nullable
              as List<MonitoringModel>,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$MonitoringStateImpl implements _MonitoringState {
  const _$MonitoringStateImpl(
      {required this.screenStatus,
      required this.paginationStatus,
      required this.isLastPage,
      required this.page,
      required this.from,
      required this.filterFrom,
      required this.to,
      required this.filterTo,
      required final List<MonitoringModel> monitoringList,
      required this.error})
      : _monitoringList = monitoringList;

  @override
  final NetworkStatus screenStatus;
  @override
  final NetworkStatus paginationStatus;
  @override
  final bool isLastPage;
  @override
  final int page;
  @override
  final String from;
  @override
  final String filterFrom;
  @override
  final String to;
  @override
  final String filterTo;
  final List<MonitoringModel> _monitoringList;
  @override
  List<MonitoringModel> get monitoringList {
    if (_monitoringList is EqualUnmodifiableListView) return _monitoringList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_monitoringList);
  }

  @override
  final String error;

  @override
  String toString() {
    return 'MonitoringState(screenStatus: $screenStatus, paginationStatus: $paginationStatus, isLastPage: $isLastPage, page: $page, from: $from, filterFrom: $filterFrom, to: $to, filterTo: $filterTo, monitoringList: $monitoringList, error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MonitoringStateImpl &&
            (identical(other.screenStatus, screenStatus) ||
                other.screenStatus == screenStatus) &&
            (identical(other.paginationStatus, paginationStatus) ||
                other.paginationStatus == paginationStatus) &&
            (identical(other.isLastPage, isLastPage) ||
                other.isLastPage == isLastPage) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.from, from) || other.from == from) &&
            (identical(other.filterFrom, filterFrom) ||
                other.filterFrom == filterFrom) &&
            (identical(other.to, to) || other.to == to) &&
            (identical(other.filterTo, filterTo) ||
                other.filterTo == filterTo) &&
            const DeepCollectionEquality()
                .equals(other._monitoringList, _monitoringList) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      screenStatus,
      paginationStatus,
      isLastPage,
      page,
      from,
      filterFrom,
      to,
      filterTo,
      const DeepCollectionEquality().hash(_monitoringList),
      error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MonitoringStateImplCopyWith<_$MonitoringStateImpl> get copyWith =>
      __$$MonitoringStateImplCopyWithImpl<_$MonitoringStateImpl>(
          this, _$identity);
}

abstract class _MonitoringState implements MonitoringState {
  const factory _MonitoringState(
      {required final NetworkStatus screenStatus,
      required final NetworkStatus paginationStatus,
      required final bool isLastPage,
      required final int page,
      required final String from,
      required final String filterFrom,
      required final String to,
      required final String filterTo,
      required final List<MonitoringModel> monitoringList,
      required final String error}) = _$MonitoringStateImpl;

  @override
  NetworkStatus get screenStatus;
  @override
  NetworkStatus get paginationStatus;
  @override
  bool get isLastPage;
  @override
  int get page;
  @override
  String get from;
  @override
  String get filterFrom;
  @override
  String get to;
  @override
  String get filterTo;
  @override
  List<MonitoringModel> get monitoringList;
  @override
  String get error;
  @override
  @JsonKey(ignore: true)
  _$$MonitoringStateImplCopyWith<_$MonitoringStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
